{% extends 'base.html' %}

{% block title %}ãƒãƒ³ãƒ‰ãƒªãƒãƒ¼ã‚µãƒ«ç®¡ç† - ã‚¿ã‚¤ãƒãƒ¼{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-md-8">
        <h1>ğŸµ ãƒãƒ³ãƒ‰ãƒªãƒãƒ¼ã‚µãƒ«ç®¡ç†</h1>
        <p class="text-muted">ç·´ç¿’ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†ã—ã¾ã™</p>
    </div>
    <div class="col-md-4 text-end">
        <a href="/admin/timer_core/timer/add/" class="btn btn-outline-success">ã‚¿ã‚¤ãƒãƒ¼è¿½åŠ </a>
        <a href="/admin/" class="btn btn-outline-secondary">ç®¡ç†ç”»é¢</a>
    </div>
</div>

{% if timers %}
    <!-- ã‚¿ã‚¤ãƒãƒ¼åˆ¶å¾¡ãƒ‘ãƒãƒ« -->
    <div class="card mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0">â° ã‚¿ã‚¤ãƒãƒ¼åˆ¶å¾¡</h5>
        </div>
        <div class="card-body text-center">
            <div class="timer-duration mb-3" id="current-timer">
                æº–å‚™å®Œäº†
            </div>
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-success btn-lg" id="start-btn">
                    <i class="bi bi-play-fill"></i> é–‹å§‹
                </button>
                <button type="button" class="btn btn-warning btn-lg" id="pause-btn" disabled>
                    <i class="bi bi-pause-fill"></i> ä¸€æ™‚åœæ­¢
                </button>
                <button type="button" class="btn btn-info btn-lg" id="skip-btn" disabled>
                    <i class="bi bi-skip-forward-fill"></i> ã‚¹ã‚­ãƒƒãƒ—
                </button>
                <button type="button" class="btn btn-secondary btn-lg" id="stop-btn" disabled>
                    <i class="bi bi-stop-fill"></i> åœæ­¢
                </button>
            </div>
            <div class="mt-3">
                <small class="text-muted">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼: é–‹å§‹/ä¸€æ™‚åœæ­¢ | â†’ã‚­ãƒ¼: ã‚¹ã‚­ãƒƒãƒ—</small>
            </div>
        </div>
    </div>

    <!-- ã‚¿ã‚¤ãƒãƒ¼ä¸€è¦§ -->
    <div class="card">
        <div class="card-header">
            <h5 class="mb-0">ğŸ“‹ ã‚¿ã‚¤ãƒãƒ¼ä¸€è¦§ ({{ timers.count }}å€‹)</h5>
        </div>
        <div class="table-responsive">
            <table class="table table-hover mb-0">
                <thead class="table-light">
                    <tr>
                        <th>é †åº</th>
                        <th>ãƒãƒ³ãƒ‰å</th>
                        <th>æ™‚é–“</th>
                        <th>ç®¡ç†è€…</th>
                        <th>çŠ¶æ…‹</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody>
                    {% for timer in timers %}
                    <tr class="timer-row" data-timer-id="{{ timer.id }}" data-duration="{{ timer.duration_minutes }}">
                        <td>
                            <span class="badge bg-secondary">{{ timer.order }}</span>
                        </td>
                        <td>
                            <strong>{{ timer.band.name }}</strong>
                            {% if timer.name != timer.band.name %}
                                <small class="text-muted d-block">{{ timer.name }}</small>
                            {% endif %}
                        </td>
                        <td>
                            <span class="badge bg-primary">{{ timer.duration_minutes }}åˆ†</span>
                        </td>
                        <td>
                            {% if timer.manager1 %}
                                <span class="badge bg-info manager-badge me-1">{{ timer.manager1 }}</span>
                            {% endif %}
                            {% if timer.manager2 %}
                                <span class="badge bg-info manager-badge me-1">{{ timer.manager2 }}</span>
                            {% endif %}
                            {% if timer.manager3 %}
                                <span class="badge bg-info manager-badge">{{ timer.manager3 }}</span>
                            {% endif %}
                        </td>
                        <td>
                            <span class="badge bg-light text-dark status-badge">å¾…æ©Ÿä¸­</span>
                        </td>
                        <td>
                            <a href="/admin/timer_core/timer/{{ timer.id }}/change/" class="btn btn-sm btn-outline-primary">ç·¨é›†</a>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>

    <!-- é€²æ—è¡¨ç¤º -->
    <div class="card mt-4">
        <div class="card-body">
            <h6>é€²æ—çŠ¶æ³</h6>
            <div class="progress">
                <div class="progress-bar" role="progressbar" style="width: 0%" id="progress-bar">
                    0 / {{ timers.count }}
                </div>
            </div>
        </div>
    </div>

{% else %}
    <div class="alert alert-warning">
        <h4>ã‚¿ã‚¤ãƒãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</h4>
        <p>ã¾ãšã¯ãƒãƒ³ãƒ‰ã¨ã‚¿ã‚¤ãƒãƒ¼ã‚’ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚</p>
        <a href="/admin/timer_core/band/add/" class="btn btn-primary me-2">ãƒãƒ³ãƒ‰ã‚’è¿½åŠ </a>
        <a href="/admin/timer_core/timer/add/" class="btn btn-outline-primary">ã‚¿ã‚¤ãƒãƒ¼ã‚’è¿½åŠ </a>
    </div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
class ServerTimerManager {
    constructor() {
        this.currentSessionId = null;
        this.statusInterval = null;
        this.websocket = null;
        this.bandId = 1; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ³ãƒ‰IDï¼ˆå¾Œã§å‹•çš„ã«è¨­å®šäºˆå®šï¼‰
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.loadExistingSession();
        this.initWebSocket();
    }
    
    initWebSocket() {
        // WebSocketæ¥ç¶šï¼ˆPhase 3 æº–å‚™ï¼‰
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsPath = `${wsScheme}://${window.location.host}/ws/timer/${this.bandId}/`;
        
        console.log('WebSocketæ¥ç¶šè©¦è¡Œ:', wsPath);
        
        try {
            this.websocket = new WebSocket(wsPath);
            
            this.websocket.onopen = (event) => {
                console.log('WebSocketæ¥ç¶šæˆåŠŸ');
                this.showConnectionStatus('WebSocketæ¥ç¶šæ¸ˆã¿', 'success');
            };
            
            this.websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡:', data);
                this.handleWebSocketMessage(data);
            };
            
            this.websocket.onclose = (event) => {
                console.log('WebSocketåˆ‡æ–­:', event.code);
                this.showConnectionStatus('WebSocketåˆ‡æ–­', 'warning');
                // 5ç§’å¾Œã«å†æ¥ç¶šè©¦è¡Œ
                setTimeout(() => this.initWebSocket(), 5000);
            };
            
            this.websocket.onerror = (error) => {
                console.error('WebSocketã‚¨ãƒ©ãƒ¼:', error);
                this.showConnectionStatus('WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼', 'error');
            };
            
        } catch (error) {
            console.error('WebSocketåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            this.showConnectionStatus('WebSocketåˆ©ç”¨ä¸å¯', 'error');
        }
    }
    
    handleWebSocketMessage(data) {
        switch (data.type) {
            case 'connection_established':
                console.log('æ¥ç¶šç¢ºç«‹:', data.message);
                break;
                
            case 'timer_update':
                // å°†æ¥: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
                console.log('ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°:', data.data);
                break;
                
            case 'timer_completed':
                // å°†æ¥: ã‚¿ã‚¤ãƒãƒ¼å®Œäº†é€šçŸ¥
                console.log('ã‚¿ã‚¤ãƒãƒ¼å®Œäº†:', data.data);
                break;
                
            case 'pong':
                console.log('ãƒãƒ³ã‚°å—ä¿¡');
                break;
                
            default:
                console.log('æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—:', data);
        }
    }
    
    showConnectionStatus(message, type) {
        // æ¥ç¶šçŠ¶æ…‹è¡¨ç¤ºï¼ˆPhase 3ã§æœ¬æ ¼å®Ÿè£…äºˆå®šï¼‰
        const statusElement = document.getElementById('connection-status');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.className = `alert alert-${type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'danger'}`;
        }
    }
    
    sendWebSocketMessage(message) {
        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify(message));
        }
    }
    
    bindEvents() {
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const skipBtn = document.getElementById('skip-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        startBtn.addEventListener('click', () => this.startTimer());
        
        // WebSocketãƒ†ã‚¹ãƒˆç”¨ãƒ”ãƒ³ã‚°ãƒœã‚¿ãƒ³ï¼ˆé–‹ç™ºç”¨ï¼‰
        const pingBtn = document.getElementById('ping-btn');
        if (pingBtn) {
            pingBtn.addEventListener('click', () => {
                this.sendWebSocketMessage({
                    type: 'ping',
                    timestamp: Date.now()
                });
            });
        }
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                this.startTimer();
            } else if (event.code === 'ArrowRight') {
                event.preventDefault();
                console.log('ã‚¹ã‚­ãƒƒãƒ—æ©Ÿèƒ½ã¯é–‹ç™ºä¸­ã§ã™');
            }
        });
    }
    
    async startTimer() {
        const timerRows = document.querySelectorAll('.timer-row');
        if (timerRows.length === 0) {
            alert('ã‚¿ã‚¤ãƒãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“');
            return;
        }
        
        // æœ€åˆã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ç”¨
        const firstTimer = timerRows[0];
        const timerId = firstTimer.dataset.timerId;
        
        try {
            const response = await fetch('/api/start-timer/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCsrfToken()
                },
                body: JSON.stringify({
                    timer_id: timerId
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                this.currentSessionId = data.session_id;
                this.updateUI('running');
                this.startStatusPolling();
                
                document.getElementById('current-timer').textContent = data.message;
                localStorage.setItem('currentSessionId', this.currentSessionId);
                
                // WebSocketã§ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹ã‚’é€šçŸ¥ï¼ˆPhase 3ç”¨æº–å‚™ï¼‰
                this.sendWebSocketMessage({
                    type: 'timer_started',
                    session_id: this.currentSessionId,
                    timer_id: timerId
                });
                
            } else {
                alert('ã‚¨ãƒ©ãƒ¼: ' + data.message);
            }
            
        } catch (error) {
            console.error('ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
            alert('ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
    }
    
    async checkTimerStatus() {
        if (!this.currentSessionId) return;
        
        try {
            const response = await fetch(`/api/timer-status/${this.currentSessionId}/`);
            const data = await response.json();
            
            if (data.success && data.status.status !== 'not_found') {
                this.updateTimerDisplay(data.status);
            } else {
                this.stopStatusPolling();
                this.updateUI('stopped');
            }
            
        } catch (error) {
            console.error('ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        }
    }
    
    updateTimerDisplay(status) {
        const currentTimerElement = document.getElementById('current-timer');
        const progressBar = document.getElementById('progress-bar');
        
        if (status.status === 'running') {
            const minutes = Math.floor(status.remaining_seconds / 60);
            const seconds = status.remaining_seconds % 60;
            currentTimerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            const progress = ((status.total_seconds - status.remaining_seconds) / status.total_seconds) * 100;
            progressBar.style.width = `${progress}%`;
            
        } else if (status.status === 'completed') {
            currentTimerElement.textContent = 'ã‚¿ã‚¤ãƒãƒ¼å®Œäº†ï¼';
            progressBar.style.width = '100%';
            this.stopStatusPolling();
            this.updateUI('completed');
            
            alert('ã‚¿ã‚¤ãƒãƒ¼ãŒå®Œäº†ã—ã¾ã—ãŸï¼');
        }
    }
    
    startStatusPolling() {
        this.statusInterval = setInterval(() => {
            this.checkTimerStatus();
        }, 1000);
    }
    
    stopStatusPolling() {
        if (this.statusInterval) {
            clearInterval(this.statusInterval);
            this.statusInterval = null;
        }
    }
    
    updateUI(state) {
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const skipBtn = document.getElementById('skip-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        if (state === 'running') {
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            skipBtn.disabled = false;
            stopBtn.disabled = false;
        } else {
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            skipBtn.disabled = true;
            stopBtn.disabled = true;
        }
    }
    
    loadExistingSession() {
        const savedSessionId = localStorage.getItem('currentSessionId');
        if (savedSessionId) {
            this.currentSessionId = savedSessionId;
            this.checkTimerStatus();
            this.startStatusPolling();
        }
    }
    
    getCsrfToken() {
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
            const [name, value] = cookie.trim().split('=');
            if (name === 'csrftoken') {
                return value;
            }
        }
        return '';
    }
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', function() {
    window.timerManager = new ServerTimerManager();
});
</script>
{% endblock %}